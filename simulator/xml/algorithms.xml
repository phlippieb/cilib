<simulator>
    <algorithms>

        <!-- 
            gbest pso
        -->
        <algorithm id="gbest.5" class="pso.PSO">
            <initialisationStrategy class="algorithm.initialisation.ClonedPopulationInitialisationStrategy">
                <entityNumber value="5"/>
                <entityType class="pso.particle.StandardParticle"/>
            </initialisationStrategy>
            <iterationStrategy class="pso.iterationstrategies.ASynchronousIterationStrategy">
                <boundaryConstraint class="problem.boundaryconstraint.RandomBoundaryConstraint" />
            </iterationStrategy>
            <addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="2000"/>
            <!--addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="0">
                <measurement class="measurement.single.Fitness"/>
                <predicate class="stoppingcondition.Minimum"/>
            </addStoppingCondition-->
        </algorithm>
        <algorithm id="gbest.25" class="pso.PSO">
            <initialisationStrategy class="algorithm.initialisation.ClonedPopulationInitialisationStrategy">
                <entityNumber value="25"/>
                <entityType class="pso.particle.StandardParticle"/>
            </initialisationStrategy>
            <iterationStrategy class="pso.iterationstrategies.ASynchronousIterationStrategy">
                <boundaryConstraint class="problem.boundaryconstraint.RandomBoundaryConstraint" />
            </iterationStrategy>
            <addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="2000"/>
            <!--addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="0">
                <measurement class="measurement.single.Fitness"/>
                <predicate class="stoppingcondition.Minimum"/>
            </addStoppingCondition-->
        </algorithm>
        <algorithm id="gbest.100" class="pso.PSO">
            <initialisationStrategy class="algorithm.initialisation.ClonedPopulationInitialisationStrategy">
                <entityNumber value="100"/>
                <entityType class="pso.particle.StandardParticle"/>
            </initialisationStrategy>
            <iterationStrategy class="pso.iterationstrategies.ASynchronousIterationStrategy">
                <boundaryConstraint class="problem.boundaryconstraint.RandomBoundaryConstraint" />
            </iterationStrategy>
            <addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="2000"/>
            <!--addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="0">
                <measurement class="measurement.single.Fitness"/>
                <predicate class="stoppingcondition.Minimum"/>
            </addStoppingCondition-->
        </algorithm>



        <!--
            lbest pso
        -->
        <algorithm id="lbest.5" class="pso.PSO">
            <initialisationStrategy class="algorithm.initialisation.ClonedPopulationInitialisationStrategy">
                <entityNumber value="5"/>
                <entityType class="pso.particle.StandardParticle"/>
            </initialisationStrategy>
            <iterationStrategy class="pso.iterationstrategies.ASynchronousIterationStrategy">
                <boundaryConstraint class="problem.boundaryconstraint.RandomBoundaryConstraint" />
            </iterationStrategy>
            <topology class="entity.topologies.LBestTopology"/>
            <addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="2000"/>
            <!--addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="0">
                <measurement class="measurement.single.Fitness"/>
                <predicate class="stoppingcondition.Minimum"/>
            </addStoppingCondition-->
        </algorithm>
        <algorithm id="lbest.25" class="pso.PSO">
            <initialisationStrategy class="algorithm.initialisation.ClonedPopulationInitialisationStrategy">
                <entityNumber value="25"/>
                <entityType class="pso.particle.StandardParticle"/>
            </initialisationStrategy>
            <iterationStrategy class="pso.iterationstrategies.ASynchronousIterationStrategy">
                <boundaryConstraint class="problem.boundaryconstraint.RandomBoundaryConstraint" />
            </iterationStrategy>
            <topology class="entity.topologies.LBestTopology"/>
            <addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="2000"/>
            <!--addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="0">
                <measurement class="measurement.single.Fitness"/>
                <predicate class="stoppingcondition.Minimum"/>
            </addStoppingCondition-->
        </algorithm>
        <algorithm id="lbest.100" class="pso.PSO">
            <initialisationStrategy class="algorithm.initialisation.ClonedPopulationInitialisationStrategy">
                <entityNumber value="100"/>
                <entityType class="pso.particle.StandardParticle"/>
            </initialisationStrategy>
            <iterationStrategy class="pso.iterationstrategies.ASynchronousIterationStrategy">
                <boundaryConstraint class="problem.boundaryconstraint.RandomBoundaryConstraint" />
            </iterationStrategy>
            <topology class="entity.topologies.LBestTopology"/>
            <addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="2000"/>
            <!--addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="0">
                <measurement class="measurement.single.Fitness"/>
                <predicate class="stoppingcondition.Minimum"/>
            </addStoppingCondition-->
        </algorithm>



        <!--
            guaranteed convergence pso
        -->
        <algorithm id="gcpso.5" class="pso.PSO">
            <initialisationStrategy class="algorithm.initialisation.ClonedPopulationInitialisationStrategy">
                <entityNumber value="5"/>
                <entityType class="pso.particle.StandardParticle">
                    <velocityProvider class="pso.velocityprovider.GCVelocityProvider"/>
                </entityType>
            </initialisationStrategy>
            <iterationStrategy class="pso.iterationstrategies.ASynchronousIterationStrategy">
                <boundaryConstraint class="problem.boundaryconstraint.RandomBoundaryConstraint" />
            </iterationStrategy>
            <topology class="entity.topologies.LBestTopology"/>
            <addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="2000"/>
            <!--addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="0">
                <measurement class="measurement.single.Fitness"/>
                <predicate class="stoppingcondition.Minimum"/>
            </addStoppingCondition-->
        </algorithm>
        <algorithm id="gcpso.25" class="pso.PSO">
            <initialisationStrategy class="algorithm.initialisation.ClonedPopulationInitialisationStrategy">
                <entityNumber value="25"/>
                <entityType class="pso.particle.StandardParticle">
                    <velocityProvider class="pso.velocityprovider.GCVelocityProvider"/>
                </entityType>
            </initialisationStrategy>
            <iterationStrategy class="pso.iterationstrategies.ASynchronousIterationStrategy">
                <boundaryConstraint class="problem.boundaryconstraint.RandomBoundaryConstraint" />
            </iterationStrategy>
            <topology class="entity.topologies.LBestTopology"/>
            <addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="2000"/>
            <!--addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="0">
                <measurement class="measurement.single.Fitness"/>
                <predicate class="stoppingcondition.Minimum"/>
            </addStoppingCondition-->
        </algorithm>
        <algorithm id="gcpso.100" class="pso.PSO">
            <initialisationStrategy class="algorithm.initialisation.ClonedPopulationInitialisationStrategy">
                <entityNumber value="100"/>
                <entityType class="pso.particle.StandardParticle">
                    <velocityProvider class="pso.velocityprovider.GCVelocityProvider"/>
                </entityType>
            </initialisationStrategy>
            <iterationStrategy class="pso.iterationstrategies.ASynchronousIterationStrategy">
                <boundaryConstraint class="problem.boundaryconstraint.RandomBoundaryConstraint" />
            </iterationStrategy>
            <topology class="entity.topologies.LBestTopology"/>
            <addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="2000"/>
            <!--addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="0">
                <measurement class="measurement.single.Fitness"/>
                <predicate class="stoppingcondition.Minimum"/>
            </addStoppingCondition-->
        </algorithm>
    </algorithms>


    <!--
        Social PSO
    -->
    <algorithm id="spso.5" class="pso.PSO">
        <initialisationStrategy class="algorithm.initialisation.ClonedPopulationInitialisationStrategy">
            <entityNumber value="5"/>
            <entityType class="pso.particle.StandardParticle">
                <velocityProvider class="pso.velocityprovider.StandardVelocityProvider">
                    <cognitiveAcceleration class="controlparameter.ConstantControlParameter" parameter="0"/>
                </velocityProvider>
            </entityType>
        </initialisationStrategy>
        <iterationStrategy class="pso.iterationstrategies.ASynchronousIterationStrategy">
            <boundaryConstraint class="problem.boundaryconstraint.RandomBoundaryConstraint"/>
        </iterationStrategy>
        <topology class="entity.topologies.VonNeumannTopology"/>
        <addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="2000"/>
        <!--addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="0">
            <measurement class="measurement.single.Fitness"/>
            <predicate class="stoppingcondition.Minimum"/>
        </addStoppingCondition-->
    </algorithm>
    <algorithm id="spso.25" class="pso.PSO">
        <initialisationStrategy class="algorithm.initialisation.ClonedPopulationInitialisationStrategy">
            <entityNumber value="25"/>
            <entityType class="pso.particle.StandardParticle">
                <velocityProvider class="pso.velocityprovider.StandardVelocityProvider">
                    <cognitiveAcceleration class="controlparameter.ConstantControlParameter" parameter="0"/>
                </velocityProvider>
            </entityType>
        </initialisationStrategy>
        <iterationStrategy class="pso.iterationstrategies.ASynchronousIterationStrategy">
            <boundaryConstraint class="problem.boundaryconstraint.RandomBoundaryConstraint"/>
        </iterationStrategy>
        <topology class="entity.topologies.VonNeumannTopology"/>
        <addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="2000"/>
        <!--addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="0">
            <measurement class="measurement.single.Fitness"/>
            <predicate class="stoppingcondition.Minimum"/>
        </addStoppingCondition-->
    </algorithm>
    <algorithm id="spso.100" class="pso.PSO">
        <initialisationStrategy class="algorithm.initialisation.ClonedPopulationInitialisationStrategy">
            <entityNumber value="100"/>
            <entityType class="pso.particle.StandardParticle">
                <velocityProvider class="pso.velocityprovider.StandardVelocityProvider">
                    <cognitiveAcceleration class="controlparameter.ConstantControlParameter" parameter="0"/>
                </velocityProvider>
            </entityType>
        </initialisationStrategy>
        <iterationStrategy class="pso.iterationstrategies.ASynchronousIterationStrategy">
            <boundaryConstraint class="problem.boundaryconstraint.RandomBoundaryConstraint"/>
        </iterationStrategy>
        <topology class="entity.topologies.VonNeumannTopology"/>
        <addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="2000"/>
        <!--addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="0">
            <measurement class="measurement.single.Fitness"/>
            <predicate class="stoppingcondition.Minimum"/>
        </addStoppingCondition-->
    </algorithm>


    <!--
        Cognitive PSO
    -->
    <algorithm id="cpso.5" class="pso.PSO">
        <initialisationStrategy class="algorithm.initialisation.ClonedPopulationInitialisationStrategy">
            <entityNumber value="5"/>
            <entityType class="pso.particle.StandardParticle">
                <velocityProvider class="pso.velocityprovider.ClampingVelocityProvider">
                    <delegate class="pso.velocityprovider.StandardVelocityProvider">
                        <socialAcceleration class="controlparameter.ConstantControlParameter" parameter="0"/>
                        <cognitiveAcceleration class="controlparameter.ConstantControlParameter" parameter="1.5" />
                        <inertiaWeight class="controlparameter.ConstantControlParameter" parameter="0.99" />
                    </delegate>
                    <vMax class="controlparameter.ConstantControlParameter" parameter="100"/>
                </velocityProvider>
                <velocityInitialisationStrategy class="entity.initialisation.RandomBoundedInitialisationStrategy">
                    <lowerBound class="controlparameter.ConstantControlParameter" parameter="1.0"/>
                    <upperBound class="controlparameter.ConstantControlParameter" parameter="100.0"/>
                </velocityInitialisationStrategy>
                <!--personalBestInitialisationStrategy class="entity.initialisation.RandomInitialisationStrategy"/-->
            </entityType>
        </initialisationStrategy>
        <iterationStrategy class="pso.iterationstrategies.ASynchronousIterationStrategy">
            <boundaryConstraint class="problem.boundaryconstraint.RandomBoundaryConstraint"/>
        </iterationStrategy>
        <topology class="entity.topologies.VonNeumannTopology"/>
        <addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="2000"/>
        <!--addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="0">
            <measurement class="measurement.single.Fitness"/>
            <predicate class="stoppingcondition.Minimum"/>
        </addStoppingCondition-->
    </algorithm>
    <algorithm id="cpso.25" class="pso.PSO">
        <initialisationStrategy class="algorithm.initialisation.ClonedPopulationInitialisationStrategy">
            <entityNumber value="25"/>
            <entityType class="pso.particle.StandardParticle">
                <velocityProvider class="pso.velocityprovider.ClampingVelocityProvider">
                    <delegate class="pso.velocityprovider.StandardVelocityProvider">
                        <socialAcceleration class="controlparameter.ConstantControlParameter" parameter="0"/>
                        <cognitiveAcceleration class="controlparameter.ConstantControlParameter" parameter="1.5" />
                        <inertiaWeight class="controlparameter.ConstantControlParameter" parameter="0.99" />
                    </delegate>
                    <vMax class="controlparameter.ConstantControlParameter" parameter="100"/>
                </velocityProvider>
                <velocityInitialisationStrategy class="entity.initialisation.RandomBoundedInitialisationStrategy">
                    <lowerBound class="controlparameter.ConstantControlParameter" parameter="1.0"/>
                    <upperBound class="controlparameter.ConstantControlParameter" parameter="100.0"/>
                </velocityInitialisationStrategy>
                <!--personalBestInitialisationStrategy class="entity.initialisation.RandomInitialisationStrategy"/-->
            </entityType>
        </initialisationStrategy>
        <iterationStrategy class="pso.iterationstrategies.ASynchronousIterationStrategy">
            <boundaryConstraint class="problem.boundaryconstraint.RandomBoundaryConstraint"/>
        </iterationStrategy>
        <topology class="entity.topologies.VonNeumannTopology"/>
        <addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="2000"/>
        <!--addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="0">
            <measurement class="measurement.single.Fitness"/>
            <predicate class="stoppingcondition.Minimum"/>
        </addStoppingCondition-->
    </algorithm>
    <algorithm id="cpso.100" class="pso.PSO">
        <initialisationStrategy class="algorithm.initialisation.ClonedPopulationInitialisationStrategy">
            <entityNumber value="100"/>
            <entityType class="pso.particle.StandardParticle">
                <velocityProvider class="pso.velocityprovider.ClampingVelocityProvider">
                    <delegate class="pso.velocityprovider.StandardVelocityProvider">
                        <socialAcceleration class="controlparameter.ConstantControlParameter" parameter="0"/>
                        <cognitiveAcceleration class="controlparameter.ConstantControlParameter" parameter="1.5" />
                        <inertiaWeight class="controlparameter.ConstantControlParameter" parameter="0.99" />
                    </delegate>
                    <vMax class="controlparameter.ConstantControlParameter" parameter="100"/>
                </velocityProvider>
                <velocityInitialisationStrategy class="entity.initialisation.RandomBoundedInitialisationStrategy">
                    <lowerBound class="controlparameter.ConstantControlParameter" parameter="1.0"/>
                    <upperBound class="controlparameter.ConstantControlParameter" parameter="100.0"/>
                </velocityInitialisationStrategy>
                <!--personalBestInitialisationStrategy class="entity.initialisation.RandomInitialisationStrategy"/-->
            </entityType>
        </initialisationStrategy>
        <iterationStrategy class="pso.iterationstrategies.ASynchronousIterationStrategy">
            <boundaryConstraint class="problem.boundaryconstraint.RandomBoundaryConstraint"/>
        </iterationStrategy>
        <topology class="entity.topologies.VonNeumannTopology"/>
        <addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="2000"/>
        <!--addStoppingCondition class="stoppingcondition.MeasuredStoppingCondition" target="0">
            <measurement class="measurement.single.Fitness"/>
            <predicate class="stoppingcondition.Minimum"/>
        </addStoppingCondition-->
    </algorithm>

</simulator>